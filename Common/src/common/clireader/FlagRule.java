package common.clireader;

import java.text.ParseException;
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import common.cli.CommandLineReader;

/**
 * This class represents a single command-line flag, used to define a flag rule.
 *
 * It retains data regarding the flag name and type (short or long), along with the capability to
 * determine if the flag requires an argument or value.
 *
 * <b>Important:</b> Once an instance of this class is created, the registered flag cannot be
 * altered. Each instance is generated by the implementing class {@link CommandLineReader} and must
 * possess either a short flag name (single character) or a long flag name and the associated flag
 * type.
 *
 * @author Trevor Maggs
 * @version 1.0
 * @since 26 February 2026
 */
public class FlagRule
{
    final private FlagType flagType;
    final private boolean longFlag;
    final private String flagName;
    final private List<String> values;
    private boolean handled;
    private boolean separator;

    /**
     * Defines the expected behaviour for flag arguments and separators.
     */
    public enum FlagType
    {
        /** Mandatory value required (e.g., -f value) */
        ARG_REQUIRED,
        /** Optional value permitted (e.g., -f [value]) */
        ARG_OPTIONAL,
        /** Mandatory value via separator (e.g., --file=data.txt) */
        SEP_REQUIRED,
        /** Optional value via separator (e.g., --file[=data.txt]) */
        SEP_OPTIONAL,
        /** Boolean flag with no associated value (e.g., --verbose) */
        ARG_BLANK
    }

    /**
     * Internal constructor to create a new flag instance and register the flag name and type.
     *
     * @param flag
     *        the command flag name, which can be either a short flag (prefixed by a single
     *        dash, e.g., -v) or a long flag (prefixed by a double dash, e.g., --csv)
     * @param type
     *        the flag rule type, defining how arguments and separators are handled
     *
     * @throws ParseException
     *         if the specified flag contains invalid characters or if a short flag exceeds a
     *         single character
     */
    public FlagRule(String flag, FlagType type) throws ParseException
    {
        if (flag == null || !flag.matches("\\-{1,2}[^\\-].*$"))
        {
            throw new ParseException("Flag [" + flag + "] is invalid.", 0);
        }

        this.flagName = flag;
        this.flagType = type;
        this.longFlag = flag.startsWith("--");
        this.values = new ArrayList<>();

        if (!longFlag && flag.length() > 2)
        {
            throw new ParseException("Short flag rules must be a single character, for example: '-v'. Found [" + flag + "].", 0);
        }
    }

    /**
     * Retrieves the name of this flag.
     *
     * @return the flag name
     */
    public String getFlagName()
    {
        return flagName;
    }

    /**
     * Retrieves the type of this flag.
     *
     * @return the {@link FlagType}, which defines this flag
     */
    public FlagType getFlagType()
    {
        return flagType;
    }

    /**
     * Associates a non-null value with this command flag.
     *
     * @param value
     *        the string value parsed from the command line to be associated with this rule
     */
    public void addValue(String value)
    {
        if (value != null)
        {
            values.add(value);
        }
    }

    /**
     * Returns the number of values stored within this flag.
     *
     * @return the count of assigned values
     */
    public int getSize()
    {
        return values.size();
    }

    /**
     * Returns true if the flag is a short flag type, for example: -v.
     *
     * @return true if it is a short flag
     */
    public boolean isShortFlag()
    {
        return !longFlag;
    }

    /**
     * Returns true if the flag is a long flag type, for example: --verbose.
     *
     * @return true if it is a long flag
     */
    public boolean isLongFlag()
    {
        return longFlag;
    }

    /**
     * Returns whether this flag requires or permits at least one argument.
     *
     * @return true if an argument is expected or optional, false otherwise
     */
    public boolean expectsArgument()
    {
        switch (flagType)
        {
            case ARG_REQUIRED:
            case ARG_OPTIONAL:
            case SEP_REQUIRED:
            case SEP_OPTIONAL:
                return true;
            default:
                return false;
        }
    }

    /**
     * Resets this flag to its initial state.
     * 
     * <p>
     * This clears the internal 'handled' status and separator detection, allowing the rule to be
     * reused in a subsequent parsing pass. Note that this does not clear the associated values
     * list.
     * </p>
     */
    public void resetFlag()
    {
        handled = false;
        separator = false;
        // values.clear(); <-- TEST FIRST
    }

    /**
     * Sets a status indicating that this flag has been handled, including processing any
     * associated arguments or values.
     */
    public void setFlagHandled()
    {
        handled = true;
    }

    /**
     * Returns whether this flag has been handled during the current parsing phase.
     *
     * @return true if the processing of this flag is complete, false otherwise
     */
    public boolean isFlagHandled()
    {
        return handled;
    }

    /**
     * Returns whether this is a mandatory flag that must be accompanied by an argument or
     * separator.
     *
     * @return true if the flag is required, false otherwise
     */
    public boolean isRequired()
    {
        return (flagType == FlagType.ARG_REQUIRED || flagType == FlagType.SEP_REQUIRED);
    }

    /**
     * Checks if this flag is strictly bound by the value separator (=) rule.
     *
     * @return true if the value separator is required or permitted, false otherwise
     */
    public boolean expectsSeparator()
    {
        return (flagType == FlagType.SEP_REQUIRED || flagType == FlagType.SEP_OPTIONAL);
    }

    /**
     * Sets this flag to expect an accompanying value subsequent to encountering a value separator
     * (=).
     */
    public void setSeparator()
    {
        separator = true;
    }

    /**
     * Queries whether a value separator is currently assigned to this flag.
     *
     * @return true if a value separator has been handled, false otherwise
     */
    public boolean hasSeparator()
    {
        return separator;
    }

    /**
     * Checks if this flag has any values assigned to it.
     *
     * @return true if the flag has at least one assigned value, false otherwise
     */
    public boolean hasValueAssigned()
    {
        return (!values.isEmpty());
    }

    /**
     * Checks whether this flag has multiple values assigned.
     *
     * @return true if the flag retains more than one value, false otherwise
     */
    public boolean hasMultipleValues()
    {
        return (values.size() > 1);
    }

    /**
     * Returns a value from the specified position in the list.
     *
     * @param index
     *        the index of the value to retrieve
     * @return the value at the specified position
     * 
     * @throws IndexOutOfBoundsException
     *         if the index is out of bounds
     */
    public String getValue(int index)
    {
        if (index >= 0 && index < values.size())
        {
            return values.get(index);
        }

        throw new IndexOutOfBoundsException("Index [" + index + "] is out of bounds");
    }

    /**
     * Retrieves all values currently associated with this flag rule.
     * 
     * @return an unmodifiable {@link List} containing all assigned string values, or an empty list
     *         if no values have been associated with this flag
     */
    public List<String> getAllValues()
    {
        return (values.isEmpty() ? Collections.emptyList() : Collections.unmodifiableList(values));
    }

    /**
     * Returns a string representation of this flag rule, detailing its name, type, current parsing
     * status, and any associated values.
     *
     * @return a formatted string containing the flag's definition and parsed state
     */
    @Override
    public String toString()
    {
        return String.format("Flag [%s] | Type: %s | Status: %s | Values: %s", flagName, flagType, (handled ? "PARSED" : "PENDING"), values.isEmpty() ? "none" : String.join(", ", values));
    }
}