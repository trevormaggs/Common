package common.cli;

import static common.cli.CommandLineReader.*;
import java.text.ParseException;
import java.util.ArrayList;
import java.util.List;
import common.StringJoiner;

/**
 * This class represents a single command-line flag, which is used to define an option rule.
 *
 * It retains data about the option name and type (short, long, or extended short), along with the
 * capability to determine if the flag requires an argument or value.
 *
 * <b>Important:</b> After an instance of this class is instantiated, the registered flag cannot be
 * altered. Each instance is generated by the implementing class {@link CommandLineReader} and must
 * possess at least a short or long option name and the option type.
 *
 * @author Trevor Maggs
 * @version 1.0
 * @since 1 August 2024
 */
public class FlagOptionRule
{
    final private int optType;
    final private boolean longOpt;
    final private String optName;
    private boolean handled;
    private boolean separator;
    private List<String> values;

    /**
     * Internal constructor to create a new option instance and register the option name and type.
     *
     * @param flag
     *        the command option name, which can be either a short option (prefixed by a single
     *        dash,
     *        e.g., -v or -debug) or a long option (prefixed by a double dash, e.g., --csv)
     * @param type
     *        the option rule type, which must be one of the public constants defined in the
     *        enclosing
     *        parent class
     *
     * @throws ParseException
     *         if the specified option contains any invalid characters
     */
    public FlagOptionRule(String flag, int type) throws ParseException
    {
        optName = flag;
        optType = type;
        longOpt = flag.startsWith("--");
        values = new ArrayList<>();

        if (optName.matches("\\-{1,2}[^\\-].*$") == false)
        {
            throw new ParseException("Command option [" + optName + "] is unrecognised.", 0);
        }

        char[] ch = optName.toCharArray();

        for (int i = 1; i < ch.length; i++)
        {
            if (longOpt && i == 1)
            {
                continue;
            }

            if ((Character.isJavaIdentifierPart(ch[i]) || ch[i] == '?' || ch[i] == '@') == false)
            {
                throw new ParseException("Command option [" + optName + "] contains an illegal character [" + ch[i] + "].", 0);
            }
        }
    }

    /**
     * Retrieves the name of this option.
     *
     * @return the name of this option
     */

    public String getOptionName()
    {
        return optName;
    }

    /**
     * Retrieves the type of this option.
     * 
     * @return the type of this option, represented as an integer value
     */
    public int getOptionType()
    {
        return optType;
    }

    /**
     * Associates a value with this command option.
     * 
     * @param val
     *        the value to be associated with this command option
     */
    public void addValue(String val)
    {
        values.add(val);
    }

    /**
     * Resets this option for processing, allowing it to be handled again. This method must be
     * called before the option can be processed, enabling the program to capture the option in the
     * command line and determine whether it expects an argument or can be used as a stand-alone
     * flag.
     */
    public void resetOption()
    {
        handled = false;
        separator = false;
    }

    /**
     * Sets a flag indicating that this option has been handled, including any associated arguments
     * if any.
     */

    public void setOptionDone()
    {
        handled = true;
    }

    /**
     * Returns whether this option has been handled or not.
     * 
     * @return true if the processing of this option has been completed, false otherwise
     */
    public boolean isOptionDone()
    {
        return handled;
    }

    /**
     * Sets this option to expect an accompanying value subsequent to encountering a value separator
     * (=). This method is only applicable when the option is defined with the {@code SEP_REQUIRED}
     * or {@code SEP_OPTIONAL} rule.
     */
    public void setSeparator()
    {
        separator = true;
    }

    /**
     * Queries whether a value separator is assigned to this option.
     * 
     * @return true if a value separator is currently assigned to this option, false otherwise
     */
    public boolean existsSeparator()
    {
        return separator;
    }

    /**
     * Returns whether this option requires at least one argument.
     * 
     * @return true if an argument is expected, false otherwise
     */
    public boolean expectsArgument()
    {
        return (optType == ARG_REQUIRED || optType == ARG_OPTIONAL || optType == SEP_REQUIRED || optType == SEP_OPTIONAL);
    }

    /**
     * Returns whether this option is a required flag.
     * 
     * @return true if this option is required, false otherwise
     */
    public boolean isRequired()
    {
        return (optType == ARG_REQUIRED || optType == SEP_REQUIRED);
    }

    /**
     * Checks if this option is bound by the value separator type rule.
     *
     * @return true if the value separator is required, false otherwise
     */
    public boolean expectsValueSeparator()
    {
        return (optType == SEP_REQUIRED || optType == SEP_OPTIONAL);
    }

    /**
     * Returns the number of elements stored in the value array.
     *
     * @return The count of values assigned
     */
    public int getSize()
    {
        return values.size();
    }

    /**
     * Checks if this option has values assigned to it.
     *
     * @return boolean true if the option has values previously assigned, false otherwise
     */
    public boolean hasValueAssigned()
    {
        return (getSize() > 0);
    }

    /**
     * Checks whether this option has at least one value assigned to it.
     *
     * @return boolean true if the option retains at least one value, false otherwise
     */
    public boolean hasMultipleValues()
    {
        return (getSize() > 1);
    }

    /**
     * Returns a value from the specified position of the list.
     *
     * @param index
     *        the position number in the list of values
     * 
     * @return the value at the specified position, or an empty string if out of bounds
     */
    public String getValue(int index)
    {
        if (index >= 0 && index < values.size())
        {
            return values.get(index);
        }

        else
        {
            return "";
        }
    }

    /**
     * Returns true if the specified flag is a short option type.
     * 
     * @return boolean true if the flag is a short option
     */
    public boolean isShortOption()
    {
        return (longOpt == false);
    }

    /**
     * Returns true if the specified flag is an extended short option type.
     * 
     * @return boolean true if the flag is an extended short option
     */
    public boolean isExtendedShortOption()
    {
        return (longOpt == false && optName.length() > 2);
    }

    /**
     * Returns true if the specified flag is a long option type.
     * 
     * @return boolean true if the flag is a long option
     */
    public boolean isLongOption()
    {
        return longOpt;
    }

    /**
     * Returns information pertaining to this option, useful for debugging.
     * 
     * @return dump information in string form
     */
    @Override
    public String toString()
    {
        return String.format("  Type: %-3s %-8s Option: %-15s Values: %s", getOptionType(), (isOptionDone() ? "Set" : "Not set"), getOptionName(), StringJoiner.join(", ", values));
    }
}